@page "/diagnostic"
@rendermode InteractiveServer
@using QiBalance.Models.DTOs
@using QiBalance.Components.ViewModels
@using System.Security.Claims
@using Microsoft.AspNetCore.Components.Authorization
@inject IJSRuntime JSRuntime
@inject IDiagnosticService DiagnosticService
@inject IRecommendationService RecommendationService
@inject NavigationManager Navigation
@inject ILogger<Diagnostic> Logger
@inject AuthenticationStateProvider AuthStateProvider
@implements IDisposable

<PageTitle>Diagnoza TCM - QiBalance</PageTitle>

<!-- Enhanced keyboard shortcuts info -->
<div class="keyboard-shortcuts-hint position-fixed end-0 m-3 p-2 bg-light rounded shadow-sm" 
     style="top: 4rem; z-index: 1050; font-size: 0.8rem; opacity: 0.8;">
    <small class="text-muted">
        <i class="bi bi-keyboard"></i> Skróty: <kbd>T</kbd> - Tak, <kbd>N</kbd> - Nie, <kbd>Spacja</kbd> - Potwierdź
    </small>
</div>

<div class="container-fluid py-4" tabindex="-1" @ref="mainContainer">
    <div class="row justify-content-center">
        <div class="col-12 col-lg-8 col-xl-6">
            <div class="row">
                <div class="col-12">
                    <h2 class="text-center mb-4">
                        <i class="bi bi-clipboard-heart me-2"></i>
                        Diagnoza TCM
                    </h2>
                    
                    @if (viewModel.IsAnonymous)
                    {
                        <div class="alert alert-info d-flex align-items-center mb-4" role="alert">
                            <i class="bi bi-info-circle-fill me-2"></i>
                            <div>
                                <strong>Tryb anonimowy:</strong> Przeprowadzasz diagnozę bez logowania. 
                                Otrzymasz rekomendacje, ale nie będą one zapisane w historii. 
                                <a href="/login" class="alert-link">Zaloguj się</a> aby zapisać wyniki.
                            </div>
                        </div>
                    }
                    else
                    {
                        <div class="alert alert-success d-flex align-items-center mb-4" role="alert">
                            <i class="bi bi-person-check-fill me-2"></i>
                            <div>
                                <strong>Zalogowany jako:</strong> @viewModel.UserEmail
                                <br>Twoje rekomendacje zostaną automatycznie zapisane.
                            </div>
                        </div>
                    }
                </div>
            </div>
            @if (viewModel.IsLoading)
            {
                <div class="text-center">
                    <div class="spinner-border text-primary mb-3" role="status" aria-label="Loading diagnostic">
                        <span class="visually-hidden">Ładowanie diagnozy...</span>
                    </div>
                    <p class="text-muted">@viewModel.LoadingMessage</p>
                </div>
            }
            else if (viewModel.HasError)
            {
                <ErrorDisplayComponent 
                    ErrorMessage="@viewModel.ErrorMessage"
                    OnRetry="@RetryDiagnostic" />
            }
            else if (viewModel.CurrentQuestion != null)
            {
                <!-- Enhanced Progress Bar with phase tooltip -->
                <DiagnosticProgressBarComponent 
                    CurrentQuestion="@viewModel.QuestionNumber"
                    TotalQuestions="@viewModel.TotalQuestions"
                    CurrentPhase="@viewModel.CurrentPhase" />

                <!-- Enhanced Phase Indicator with animation -->
                <div class="phase-indicator-container" @key="@($"phase-{viewModel.CurrentPhase}")">
                    <PhaseIndicatorComponent 
                        CurrentPhase="@viewModel.CurrentPhase" 
                        PhaseDescription="@viewModel.PhaseDescription" />
                </div>

                <!-- Enhanced Question Card with smooth transitions -->
                <div class="question-card-container" @key="@($"question-{viewModel.QuestionNumber}")">
                    <DiagnosticCardComponent 
                        CurrentQuestion="@viewModel.CurrentQuestion"
                        IsLoading="@viewModel.IsProcessingAnswer"
                        OnAnswerSelected="@HandleAnswerAsync" />
                </div>

                <!-- Enhanced session info with accessibility -->
                <div class="session-info mt-4 p-3 bg-light rounded" role="complementary" aria-label="Informacje o sesji">
                    <div class="row g-2 align-items-center">
                        <div class="col-auto">
                            <small class="text-muted">
                                <i class="bi bi-clock" aria-hidden="true"></i>
                                <span class="visually-hidden">Czas sesji:</span>
                                Sesja: @viewModel.SessionTimeRemaining
                            </small>
                        </div>
                        <div class="col-auto">
                            <small class="text-muted">
                                <i class="bi bi-person-check" aria-hidden="true"></i>
                                <span class="visually-hidden">Użytkownik:</span>
                                @viewModel.UserEmail
                            </small>
                        </div>
                        <div class="col">
                            <div class="session-health-indicator float-end" 
                                 title="@GetSessionHealthTooltip()" 
                                 aria-label="@GetSessionHealthTooltip()">
                                <span class="badge bg-@GetSessionHealthColor()">
                                    <i class="bi bi-@GetSessionHealthIcon()"></i>
                                    @GetSessionHealthText()
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
            }
        </div>
    </div>
</div>

@code {
    private DiagnosticViewModel viewModel = new();
    private Timer? sessionValidationTimer;
    private Timer? autoSaveTimer;
    private ElementReference mainContainer;
    private bool isDisposed = false;
    private string? lastFocusedElement;

    // Enhanced keyboard shortcuts
    private Dictionary<string, Func<Task>> keyboardShortcuts = new();

    protected override async Task OnInitializedAsync()
    {
        InitializeKeyboardShortcuts();
        await InitializeDiagnosticAsync();
        StartSessionValidation();
        StartAutoSave();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("setupKeyboardShortcuts", DotNetObjectReference.Create(this));
            await JSRuntime.InvokeVoidAsync("setupSmoothScrolling");
            await JSRuntime.InvokeVoidAsync("setupAccessibilityEnhancements");
        }
        
        // Restore focus after state changes
        if (!string.IsNullOrEmpty(lastFocusedElement))
        {
            await JSRuntime.InvokeVoidAsync("restoreFocus", lastFocusedElement);
            lastFocusedElement = null;
        }
    }

    private void InitializeKeyboardShortcuts()
    {
        keyboardShortcuts = new Dictionary<string, Func<Task>>
        {
            { "KeyT", () => HandleAnswerAsync(true) },
            { "KeyN", () => HandleAnswerAsync(false) },
            { "Space", () => ConfirmCurrentAnswer() },
            { "Enter", () => ConfirmCurrentAnswer() },
            { "Escape", () => ShowExitConfirmation() }
        };
    }

    [JSInvokable]
    public async Task HandleKeyboardShortcut(string key)
    {
        if (keyboardShortcuts.ContainsKey(key) && !viewModel.IsProcessingAnswer)
        {
            await keyboardShortcuts[key].Invoke();
        }
    }

    private async Task ConfirmCurrentAnswer()
    {
        if (viewModel.CurrentAnswer.HasValue && !viewModel.IsProcessingAnswer)
        {
            await HandleAnswerAsync(viewModel.CurrentAnswer.Value);
        }
    }

    private async Task ShowExitConfirmation()
    {
        var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", 
            "Czy na pewno chcesz przerwać diagnozę? Twój postęp zostanie utracony.");
        
        if (confirmed)
        {
            Navigation.NavigateTo("/");
        }
    }

    // Enhanced session health indicators
    private string GetSessionHealthTooltip()
    {
        var remaining = TimeSpan.Parse("00:" + viewModel.SessionTimeRemaining);
        return remaining.TotalMinutes switch
        {
            > 20 => "Sesja aktywna - dużo czasu pozostało",
            > 10 => "Sesja aktywna - średnio czasu pozostało", 
            > 5 => "Uwaga - mało czasu pozostało",
            _ => "Krytycznie - sesja wkrótce wygaśnie"
        };
    }

    private string GetSessionHealthColor()
    {
        var remaining = TimeSpan.Parse("00:" + viewModel.SessionTimeRemaining);
        return remaining.TotalMinutes switch
        {
            > 20 => "success",
            > 10 => "info",
            > 5 => "warning",
            _ => "danger"
        };
    }

    private string GetSessionHealthIcon()
    {
        var remaining = TimeSpan.Parse("00:" + viewModel.SessionTimeRemaining);
        return remaining.TotalMinutes switch
        {
            > 20 => "shield-check",
            > 10 => "shield",
            > 5 => "shield-exclamation", 
            _ => "shield-x"
        };
    }

    private string GetSessionHealthText()
    {
        var remaining = TimeSpan.Parse("00:" + viewModel.SessionTimeRemaining);
        return remaining.TotalMinutes switch
        {
            > 20 => "Stabilna",
            > 10 => "Aktywna",
            > 5 => "Ostrzeżenie",
            _ => "Krytyczna"
        };
    }

    private async Task InitializeDiagnosticAsync()
    {
        try
        {
            viewModel.IsLoading = true;
            viewModel.LoadingMessage = "Przygotowywanie diagnozy...";
            StateHasChanged();

            // Używaj tylko AuthenticationStateProvider
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var user = authState.User;
            var userEmail = user.Identity is { IsAuthenticated: true }
                ? user.FindFirst(c => c.Type == ClaimTypes.Email)?.Value
                : null;

            Logger.LogInformation("[DIAGNOSTIC] IsAuthenticated: {IsAuth}, Email: {Email}", user.Identity?.IsAuthenticated ?? false, userEmail ?? "null");

            if (!string.IsNullOrEmpty(userEmail))
            {
                // Zalogowany użytkownik
                viewModel.InitializeForUser(userEmail);
                viewModel.LoadingMessage = "Pobieranie pytań diagnostycznych...";
                StateHasChanged();
                Logger.LogInformation("[DIAGNOSTIC] Start for authenticated user: {UserEmail}", userEmail);
                var firstQuestion = await DiagnosticService.GetNextQuestionAsync(userEmail, 1);
                if (firstQuestion != null)
                {
                    viewModel.SetCurrentQuestion(firstQuestion, 1);
                }
                else
                {
                    throw new InvalidOperationException("Nie udało się pobrać pierwszego pytania");
                }
            }
            else
            {
                // Tryb anonimowy
                viewModel.LoadingMessage = "Rozpoczynanie diagnozy anonimowej...";
                StateHasChanged();
                Logger.LogInformation("[DIAGNOSTIC] Start for anonymous user");
                await StartAnonymousSessionAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing diagnostic");
            viewModel.SetError("Błąd inicjalizacji diagnozy. Spróbuj ponownie.");
        }
        finally
        {
            viewModel.IsLoading = false;
            StateHasChanged();
        }
    }

    private async Task StartAnonymousSessionAsync()
    {
        try
        {
            // Start anonymous session with empty symptoms (can be enhanced later)
            var session = await DiagnosticService.StartAnonymousSessionAsync(initialSymptoms: "");
            
            viewModel.InitializeForAnonymous(session.SessionId);
            
            // Get first question
            if (session.Questions.Any())
            {
                viewModel.SetCurrentQuestion(session.Questions.First(), 1);
                Logger.LogInformation("Anonymous session started: {SessionId}, First question loaded", session.SessionId);
            }
            else
            {
                throw new InvalidOperationException("Nie udało się wygenerować pytań diagnostycznych");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting anonymous diagnostic session");
            viewModel.SetError("Błąd rozpoczynania diagnozy. Spróbuj ponownie.");
        }
    }

    private async Task HandleAnswerAsync(bool answer)
    {
        if (viewModel.IsProcessingAnswer || viewModel.CurrentQuestion == null)
            return;

        try
        {
            // Store current focus for restoration
            lastFocusedElement = await JSRuntime.InvokeAsync<string>("getCurrentFocusedElementId");
            
            viewModel.SetProcessingAnswer(true, answer);
            StateHasChanged();

            Logger.LogInformation("Processing answer for question {QuestionNumber}: {Answer}, Anonymous: {IsAnonymous}", 
                viewModel.QuestionNumber, answer, viewModel.IsAnonymous);

            // Add haptic feedback for mobile devices
            await JSRuntime.InvokeVoidAsync("triggerHapticFeedback", "light");

            DiagnosticResponse response;
            
            if (viewModel.IsAnonymous && viewModel.SessionId.HasValue)
            {
                // Anonymous user flow - use session-based methods
                response = await DiagnosticService.SubmitAnswerBySessionAsync(
                    viewModel.SessionId.Value, viewModel.QuestionNumber, answer);
            }
            else if (!viewModel.IsAnonymous && !string.IsNullOrEmpty(viewModel.UserEmail))
            {
                // Authenticated user flow - use email-based methods  
                response = await DiagnosticService.SubmitAnswerAsync(
                    viewModel.UserEmail, viewModel.QuestionNumber, answer);
            }
            else
            {
                throw new InvalidOperationException("Sesja nie jest poprawnie zainicjalizowana");
            }

            await HandleDiagnosticResponse(response);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error submitting answer for question {QuestionNumber}", 
                viewModel.QuestionNumber);
            viewModel.SetError("Błąd podczas zapisywania odpowiedzi. Spróbuj ponownie.");
        }
        finally
        {
            viewModel.SetProcessingAnswer(false);
            StateHasChanged();
        }
    }

    private async Task HandleDiagnosticResponse(DiagnosticResponse response)
    {
        if (!response.HasMoreQuestions && response.Recommendations != null)
        {
            Logger.LogInformation("Diagnostic completed. Storing recommendations and navigating to results.");
            
            await StoreRecommendationsAsync(response.Recommendations);
            
            // Add completion celebration
            await JSRuntime.InvokeVoidAsync("showCompletionCelebration");
            await JSRuntime.InvokeVoidAsync("triggerHapticFeedback", "success");
            
            // Smooth transition to results
            await Task.Delay(1500);
            Navigation.NavigateTo("/recommendations");
        }
        else if (response.HasMoreQuestions && response.NextQuestion != null)
        {
            // Check for phase transition
            var newPhase = GetPhaseFromQuestionNumber(viewModel.QuestionNumber + 1);
            var isPhaseTransition = newPhase != viewModel.CurrentPhase;
            
            if (isPhaseTransition)
            {
                await ShowPhaseTransitionAsync(viewModel.CurrentPhase, newPhase);
            }
            
            viewModel.SetCurrentQuestion(response.NextQuestion, viewModel.QuestionNumber + 1);
            
            // Smooth scroll to question
            await JSRuntime.InvokeVoidAsync("smoothScrollToElement", "question-card-container");
            
            Logger.LogInformation("Loaded next question {QuestionNumber}: {QuestionText}", 
                viewModel.QuestionNumber, response.NextQuestion.QuestionText);
        }
        else
        {
            Logger.LogWarning("Unexpected response state: not completed but no next question");
            viewModel.SetError("Nieoczekiwany stan diagnozy. Skontaktuj się z obsługą.");
        }
    }

    private async Task ShowPhaseTransitionAsync(int fromPhase, int toPhase)
    {
        var phaseNames = new[] { "", "Obserwacja", "Palpacja", "Analiza" };
        var message = $"Przechodzimy do fazy {toPhase}: {phaseNames[toPhase]}";
        
        await JSRuntime.InvokeVoidAsync("showPhaseTransition", message);
        await JSRuntime.InvokeVoidAsync("triggerHapticFeedback", "medium");
        
        Logger.LogInformation("Phase transition from {FromPhase} to {ToPhase}", fromPhase, toPhase);
        
        // Wait for transition animation
        await Task.Delay(2000);
    }

    private async Task StoreRecommendationsAsync(RecommendationResult recommendations)
    {
        try
        {
            // Always store in session storage for immediate display
            var recommendationsJson = System.Text.Json.JsonSerializer.Serialize(recommendations);
            await JSRuntime.InvokeVoidAsync("sessionStorage.setItem", "currentRecommendations", recommendationsJson);
            Logger.LogInformation("Recommendations stored successfully in session storage");

            // For authenticated users, also save to database
            if (!viewModel.IsAnonymous && !string.IsNullOrEmpty(viewModel.UserEmail))
            {
                try
                {
                    var savedRecommendation = await RecommendationService.SaveRecommendationAsync(
                        viewModel.UserEmail, 
                        recommendations);
                    
                    Logger.LogInformation("Recommendations saved to database for user: {UserEmail}, RecommendationId: {RecommendationId}", 
                        viewModel.UserEmail, savedRecommendation.RecommendationId);
                }
                catch (Exception dbEx)
                {
                    Logger.LogError(dbEx, "Failed to save recommendations to database for user: {UserEmail}", viewModel.UserEmail);
                    // Don't fail the entire flow if database save fails
                    // User will still see recommendations and they can retry from history page
                }
            }
            else
            {
                Logger.LogInformation("Anonymous user - recommendations not saved to database");
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to store recommendations in session storage");
        }
    }

    private int GetPhaseFromQuestionNumber(int questionNumber) => ((questionNumber - 1) / 5) + 1;

    private void StartSessionValidation()
    {
        sessionValidationTimer = new Timer(async _ => await ValidateSessionAsync(), 
            null, TimeSpan.Zero, TimeSpan.FromSeconds(30));
    }

    private void StartAutoSave()
    {
        autoSaveTimer = new Timer(async _ => await AutoSaveProgressAsync(), 
            null, TimeSpan.FromMinutes(2), TimeSpan.FromMinutes(2));
    }

    private async Task AutoSaveProgressAsync()
    {
        if (isDisposed || viewModel.IsLoading) return;

        try
        {
            var progress = new DiagnosticProgress
            {
                QuestionNumber = viewModel.QuestionNumber,
                CurrentPhase = viewModel.CurrentPhase,
                UserEmail = viewModel.UserEmail!,
                LastActivity = DateTime.UtcNow
            };

            var progressJson = System.Text.Json.JsonSerializer.Serialize(progress);
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "diagnosticProgress", progressJson);
            Logger.LogDebug("Auto-saved diagnostic progress for question {QuestionNumber}", viewModel.QuestionNumber);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to auto-save diagnostic progress");
        }
    }

    private async Task ValidateSessionAsync()
    {
        if (isDisposed || viewModel.IsLoading) return;

        try
        {
            bool isValid;
            DiagnosticSessionInfo? sessionInfo = null;

            if (viewModel.IsAnonymous && viewModel.SessionId.HasValue)
            {
                // Anonymous user validation
                isValid = await DiagnosticService.ValidateSessionByIdAsync(viewModel.SessionId.Value);
                if (isValid)
                {
                    sessionInfo = await DiagnosticService.GetSessionInfoByIdAsync(viewModel.SessionId.Value);
                }
            }
            else if (!viewModel.IsAnonymous && !string.IsNullOrEmpty(viewModel.UserEmail))
            {
                // Authenticated user validation
                isValid = await DiagnosticService.ValidateSessionAsync(viewModel.UserEmail);
                if (isValid)
                {
                    sessionInfo = await DiagnosticService.GetSessionInfoAsync(viewModel.UserEmail);
                }
            }
            else
            {
                Logger.LogWarning("Session validation failed - invalid session state");
                isValid = false;
            }

            if (!isValid)
            {
                Logger.LogWarning("Session validation failed for {SessionType} session", 
                    viewModel.IsAnonymous ? "anonymous" : "authenticated");
                await InvokeAsync(() =>
                {
                    viewModel.SetError("Sesja wygasła. Zostaniesz przekierowany na stronę główną.");
                    StateHasChanged();
                });

                await Task.Delay(3000);
                Navigation.NavigateTo("/");
            }
            else if (sessionInfo != null)
            {
                // Update session time remaining
                await InvokeAsync(() =>
                {
                    viewModel.UpdateSessionInfo(sessionInfo.TimeRemaining.ToString(@"mm\:ss"));
                    StateHasChanged();
                });
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during session validation for {SessionType} session", 
                viewModel.IsAnonymous ? "anonymous" : "authenticated");
            // Don't show error to user for session validation failures
        }
    }

    private async Task RetryDiagnostic()
    {
        viewModel.ClearError();
        await InitializeDiagnosticAsync();
    }

    public void Dispose()
    {
        if (!isDisposed)
        {
            sessionValidationTimer?.Dispose();
            autoSaveTimer?.Dispose();
            isDisposed = true;
        }
    }
}